第５章　最佳实践

本章内容

平稳退化：确保网页在js的情况下也能正常工作
分离js：把网页的结构和内容与js脚本的动作行为分开
向后兼容性：确保老版本的浏览器不会因为你的js脚本而死掉
性能：确定脚本执行的性能最优


js语言与dom构成了一个很强大的组合

５．１　　过去的错误

５．１．１　不要怪罪js

在如今的web上有数十亿的html文档。　所见即所得的网页设计工具
５．１．２　　Flash的遭遇

没有不好的技术，只有没有用好的技术

５．１．３　质疑一切
在所有的js特效中，最反感的就是弹出广告窗口
弹出的广告窗口和内容覆盖是一个典型的滥用js的例子

５．２　平稳退化

如果正确地使用了js脚本，就可以让访问者在他们的浏览器不支持js的情况下仍能顺利浏览你的网页，这就是平稳退化(graceful degradation)
一个新窗口里打开一个链接的例子，在许多电子商务网站的结算页面上都有一些指向服务条款或邮寄费用表的链接，与其让用户
点击这些链接时被带离当前页面，不如让用户仍停留在当前页面，并用一个弹出窗口来显示当前相关信息

注意：应该只在绝对必要的情况下才使用弹出窗口，因为这将涉及到网页的可访问性问题，例如，用户使用的屏幕
读取软件无法向用户说明弹出了窗口。因此，如果网页上的某个链接将弹出新窗口，最好在这个链接本身的文字中予以说明

js使用window对象的open()方法来创建新的浏览器窗口，这个方法有是三个参数：
window.open(url,name,features) 这三个参数都是可选的

１．url,第一个参数是想在新窗口里打开的网页的URL地址。如果省略这个参数，屏幕上将弹出一个空白
的浏览器窗口
２．name,第二个参数是新窗口的名字。可以在代码里通过这个名字与新窗口进行通信
３．features,第三个参数,是一个以逗号分隔的字符串，其内容是新窗口的各种属性。这些属性
包括新窗口的尺寸(宽度和高度)以及新窗口被启用或禁用的各种浏览功能(工具条，菜单条，初始显示位置，等)
对于这个参数应该掌握的原则：新窗口的浏览功能要少而精
以下这个函数是window.open()方法的一种典型应用：
    function.popUP(winURL){
        window.open(winURL,"popup","width=320,height=880");
    }


<!--我将把这个函数存入一个外部文件。因此，当需要在某个网页里使用此函数时，只要在这个网页的<head>-->
<!--部分用一个<script>标签导入那个外部文件即可。函数本身不会对网页的可访问性-->
产生任何影响，会影响到网页的只是：如何使用此函数
调用popUp函数的一个办法是使用伪协议（pseudo-protocol）

5.2.1 “javascript”:伪协议

“真”协议用来在因特网上的计算机之间传输数据包，如http协议，ftp协议等，伪协议则是一种非标准化的协议
‘js’:伪协议让我们通过一个链接来调用js函数

下面是通过“js”伪协议调用popUp()函数的具体做法

  <a href="javascript:popUp('http://www.example.com');">Example</a>

这条语句在支持“javascript”伪协议的浏览器中运行正常，较老的浏览器则会尝试打开那个链接但失败，支持
这种伪协议但禁用了js功能的浏览器会什么也不做
总之，在HTML文档里通过“javascript:” 伪协议调用js代码的做法非常不好


５．２．２　内嵌的事件处理函数

<!--事件处理函数的用途：把onclick事件处理函数作为属性嵌入<a>该处理函数将在onclick事件发生时调用图片切换函数-->
这个技巧同样可以用来调用popUp函数。但等在某个链接里用onclick事件处理函数取打开新窗口时，这个链接的
href属性似乎没有用处----与这个链接有骨干的重要信息已经都包含在它的onclick属性里了
  <a href="#" onclick="popUp('http://www.baidu.com/'); return true;">Example</a>

因为上面这条html指令里使用了return false语句，这个链接不会真的被打开。
”＃“符号是一个仅供文档内部使用的链接记号(单就这条指令而言，”＃“是未指向任何目标的内部链接)。
在某些浏览器里，“＃”　链接指向当前文档的开头。把href属性的值设置为"#"只是为了创建一个空链接。
实际工作全部由onclick属性负责完成。但是这个方法不好

５．２．３谁关心这个

网站优化　　搜索机器人（searchbot）
搜索机器人是一种自动化的程序，它们浏览web的目的是ｗｉｅｌｄ把各种网页添加到搜索引擎的数据库里，各大搜索搜索引擎都有类似的程序。
目前，只有极少数搜索机器人能够理解js代码。所以，如果你的js网页不嗯给你平稳退化，它们在搜索引擎上的排名可能大受损害

具体到popUp()函数，为其中js代码预留出退路很简单：在链接里把href属性设置为真实存在的url地址，让其成为一个有效的链接　
      <a href="http://www.baidu.com/" onclick="popUp('http://www.baidu.com/'); return true;">Example</a>
url出现两次，可以用js的this改写，this可以用来代表任何一种当前元素，所以可以用this和getAttribute()方法
提取出href属性的值
      <a href="http://www.baidu.com/" onclick="popUp(this.getAttribute('href')); return true;">Example</a>

当前链接的href属性还有一个更简洁的引用办法，使用dom的this.href属性

 <a href="http://www.baidu.com/" onclick="popUp(this.href); return true;">Example</a>

不管采用哪种方法重要的是href属性现在已经有了合法的值
所以，在把href属性设置为真实存在的ＵＲＬ地址后，即使js已经被禁用，这个链接也是可用的。虽然这个链接在功能上打了折扣，但
它并没有彻底失效。这是一个经典的"平稳退化"的例子

可以改进的地方：每当打开新窗口时，就不得不把一些js代码嵌入标记文档中，如果能把包括事件处理函数在内的所有js代码全部
放到外部文件里，这个技巧将更加完善

５．３　　向ＣＳＳ学习

５．３．１　结构与样式的分离

css(层叠样式表)　最大的优点是，它能够帮助你将web文档的内容结构（标记）和版面设计（样式）分离开了
真正能从ｃｓｓ技术获益的方法，是把样式全部转移到外部文件中去
如果你的工作是设计网页的版面，现在只需要集中精力把诸如颜色，字体和位置等在一些外部文件里设置妥当即可，
而无序再接触文档，最多只需要添加类或id属性
作为css技术的突出特点，文档结构与文档样式的分离可以确保网页都能平稳退化

５．３．２　渐进增强　（标记良好的内容就是一切）

只有正确地使用标记语言才能对内容做出准确的描述。
在给内容加上各种标记后，就可以使用css指令控制内容的显示效果。css指令构成了一个表现层。这个表现层就像一张透明的彩色薄膜
可以包裹到文档的结构上，使文档的内容呈现出各种色彩。但是即使去掉这个表现层，文档的内容也依然可以访问

所谓“渐进增强”　就是用一些额外的信息层取包裹原始数据。按照“渐进增强”　原则创建出的网页几乎都符合“平稳退化“原则

类似于CSS，JS和DOM提供的所有功能也应该构成一个额外的指令层。css代码负责提供关于"表示"的信息，js代码负责提供关于"行为"的信息
行为层的应用方式与表示层一样
要想获得最佳的"表示"效果，就应该把css代码从HTML文档里分离处理放在一些外部文件里。
推荐的做法，先把样式信息存入一个外部文件，再在文档的head部分用<link>标签来调用这个文件

５．４　分离js
前面可见的js代码已经与HTML文档分得很开，负责实际完成各项任务的js函数都已经存入外部文件，问题出现
在内嵌的事件处理函数中。
类似于使用style属性，在html文档里使用诸如onclick之类的属性也是一种既没有效率，又容易已发问题的做法
如果我们用一个“挂钩”，就像css机制中的class或id属性那样，把js代码调用行为与html文档的结构和内容分离开，
网页机会健壮得多。可以当这个链接被点击时，它将调用popUp()函数
<a href="http://www.sina.com" class="popup">LALALALALLA</a>

ｊｓ语言并不要求事件必须在html文档里处理，我们可以在外部js文件里把一个事件添加到html文档中的
某个元素上：
element.event = action...
关键是怎样才能把应该获得这个事件的元素确定下来。这个问题可以利用class或id属性来解决
如果想把一个事件添加到某个带有特定id属性的元素上，用getElementById就可以解决问题：
getElementById(id).event = action
如果事情涉及多个元素，我们可以用getElementsByTagName 和　getAttribute把事件添加到有着
特定属性的一组元素上。
具体步骤如下:
(1)把文档里的所有链接全放入一个数组里
(2) 遍历数组
(3)　如果某个链接的class属性等于popup,就表示这个链接在被点击时应该调用popUp()函数
于是，
A.把这个链接的href属性值传递给popUp()函数
B.取消这个链接的默认行为，不让这个链接把访问者带离当前窗口

下面是实现上述步骤的js代码：

var links = document.getElementsByTagName("a");
for (var i=0; i<links.length;i++) {}

以上代码将把调用popUp()函数的onclick事件添加到有关的链接上。只要把它们存入一个外部js文件，就
等于是把这些操作从html文档里分离出来了。而这就是"分离js"的含义

还有一个问题需要解决：如果把这段代码存入外部js文件，它们将无法正常运行。因为这段代码的第一行是：
var links = document.getElementsByTagName("a");
<!--这条语句将在js文件被加载时立刻执行。如果js文件从html文档的<head>部分用<script>标签调用的，-->
<!--它将在html文档之前加载到浏览器里。同样，如果<script>标签位于文档底部</body>之前，就不能保证哪个文件-->
最先结束加载(浏览器可能一次加载多个)。因为脚本加载时文档可能不完整，所以模型页不完整。没有完整的dom,
getElementsByTagName等方法就不能正常工作

必须让这些代码在html文档全部加载到浏览器之后马上开始执行。还好，html文档全部加载完毕时将触发一个
事件，这个事件有它自己的事件处理函数。
文档被加载到一个浏览器窗口里，document对象又是window对象的一个属性。当window对象触发
onload事件时，document对象已经存在。
我将把我的js代码打包在prepareLinks函数里，并把这个函数添加到window对象的onload事件上去，
这样一来，dom就可以正常工作了

5.5 向后兼容
５．５．１　对象检测　
检测浏览器对js的支持程度

只要把某个方法打包在一个if语句里，就可以根据这条if语句的条件表达式的求值结果是true(这个方法存在)还是
false（这个方法不存在）来决定应该采取怎样的行动。
这种检测称为对象检测（object detection） .几乎所有的东西（包括各种方法在内）都可以被当做
对象来对待，而这意味着我们可以容易地把不支持某个特定DOM方法的浏览器检测出来：
if (method) {
statements
}

例如，如果有一个使用了getElementById()方法的函数，就可以在调用getElementById()方法之前先检查
用户所使用的浏览器是否支持这个方法。在使用对象检测时，一定要删除方法名后面的圆括号，如果不删掉，
测试的将是方法的结果，无论方法是否存在。

function myFunction() {
 if (document.getElementById) {
    statements using getElementById}
}

可以使用逻辑非来测试
if(!method)
if (!document.getElementById) {
 return false;}

因为花括号部分只有return false一条语句，可以简写为：
if (!document.getElementById) return false;
如果需要测试多个方法或属性是否存在，可以用"逻辑或"操作符将其合并，这个操作符在js语言里
表示为两个竖线符号
if (!document.getElementById || document.getElementsByTagName) return false;

现在，按照这个思路，在用来把onclick事件添加到链接上取的网页加载脚本里插入一条if语句。那个脚本里
使用了getElementsByTagName,所以需要插入一条if语句取检查浏览器是欧服理解这方法。
这个if语句照顾了老的浏览器

５．５．２　浏览器嗅探技术　(browser sniffing)

"浏览器嗅探"　指通过提取浏览器供应商提供的信息来解决向后兼容问题。

５．６　性能考虑

５．６．１　尽量少访问dom和尽量减少标记

访问dom的方式对脚本性能会产生非常大的影响

if (document.getElementsByTagName("a").length > 0) {
    var links = document.getElementsByTagName("a");
    for (var i=0; i <links.length;i++){
        //对每个链接做点击处理
    }
}

<!--以上代码，首先，它取得了所有的<a>元素，然后检查它们的个数是不是大于０；-->
<!--然后，如果大于０，他回再次取得所有<a>元素，循环遍历这些元素并应用某些操作-->
只要是查询dom中的某些元素，浏览器都会搜索整个dom树，从中查找可能匹配的元素

var links = document.getElementsByTagName("a");
if (links.length > 0) {

    for (var i=0; i <links.length;i++){
        //对每个链接做点击处理
    }
}

要是有一个函数检查每个链接中的popup类，而另外一个函数检查每个链接中的hover类，那么同样
也会造成搜索浪费。在多个函数都会取得一组类似元素的情况下，可以考虑重构代码，把搜索结果保存
在一个全局变量里，或把一组元素直接以参数形式传递给函数。
注意，就是要尽量减少文档中的标记数量。过多不必要的元素只会增加dom树的闺蜜，进而增加遍历dom
树以查找特定元素的时间。
５．６．２　合并和放置脚本
<!--多数示例都是用外部脚本文件，在文档中通过<script>元素把它们包含进来-->

包含脚本的最佳方式就是使用外部文件，因为外部文件与标记能清晰地分离开，而且浏览器也能对站点中的多个页面
重用缓存过的相同脚本。
<!--脚本在标记中的位置对页面的初次加载事件也有很大影响。传统上，我们都把脚本放在文档的<head>区域，这种放置-->
<!--方法有一个问题。位于<head>块中的脚本会导致浏览器无法并行加载其他文件。一般来说，根据HTTP规范，浏览器每次-->
同一个域名中最多只能同事下载两个文件。而在下载脚本期间，浏览器不会下载其他任何文件，即使是来自不同域名的文件
也不会下载，所有其他资源都要等脚本加载完毕后才能下载

５．６．３　压缩脚本

也就是把脚本文件中不必要的字节，如空格和注释，统统删除
有许多压缩脚本的工具